import { auth, provider, db } from './firebase';
import { collection, addDoc, getDocs, serverTimestamp, doc, setDoc, deleteDoc } from 'firebase/firestore';
import CloudProjectsModal from './components/CloudProjectsModal';
import { signInWithPopup, signOut, onAuthStateChanged } from 'firebase/auth';
import type { User } from 'firebase/auth';
import { exportSTL } from './utils/exportSTL';
import { flipHorizontal, flipVertical, rotateLeft, rotateRight } from './utils/constants';
import { useEffect, useState } from 'react';
import { ToastContainer, toast } from 'react-toastify';
import 'react-toastify/dist/ReactToastify.css';
import './toast-theme.css';
import "./App.css";
import ToolBar from './components/ToolBar';
import ColorModal from './components/ColorModal';
import MenuBar from './components/MenuBar';
import ConfirmationModal from './components/ConfirmationModal';
import FramesModal from './components/FramesModal';
import ProgressBar from './components/ProgressBar';
import MobileEditorLayout from './components/MobileEditorLayout';
import { useGlobalStore } from "./store/useGlobalStore";
import {
  multiplier,
  floodFill as utilFloodFill,
  getLinePixels as utilGetLinePixels,
  getRectanglePerimeterPixels as utilGetRectanglePerimeterPixels,
  getCirclePerimeterPixels as utilGetCirclePerimeterPixels,
  drawLinePlot as utilDrawLinePlot,
  drawRectanglePlot as utilDrawRectanglePlot,
  drawCirclePlot as utilDrawCirclePlot,
  generateBlenderScript as utilGenerateBlenderScript
} from './utils/appUtils';




function App() {
  // Firebase Auth state
  const [user, setUser] = useState<User | null>(null);
  useEffect(() => {
    const unsub = onAuthStateChanged(auth, setUser);
    return () => unsub();
  }, []);

  const setCurrentFrame = useGlobalStore((s) => s.setCurrentFrame);
  const setSize = useGlobalStore((s) => s.setSize);
  const size = useGlobalStore((s) => s.size);
  const currColor = useGlobalStore((s) => s.currColor);
  const setCurrColor = useGlobalStore((s) => s.setCurrColor);
  const currentPixel = useGlobalStore((s) => s.currentPixel);
  const setCurrentPixel = useGlobalStore((s) => s.setCurrentPixel);
  const plot = useGlobalStore((s) => s.frames[s.currentFrame]);
  const setPlot = useGlobalStore((s) => s.setPlot);
  const colorMenuOpen = useGlobalStore((s) => s.colorMenuOpen);
  const setColorMenuOpen = useGlobalStore((s) => s.setColorMenuOpen);
  // Use local state for mouse position for smooth custom cursor
  const [mousePos, setMousePos] = useState({ x: 0, y: 0 });
  const showToolCursor = useGlobalStore((s) => s.showToolCursor);
  const setShowToolCursor = useGlobalStore((s) => s.setShowToolCursor);
  const shiftButtonEngaged = useGlobalStore((s) => s.shiftButtonEngaged);
  const setShiftButtonEngaged = useGlobalStore((s) => s.setShiftButtonEngaged);
  const voxelSizeMm = useGlobalStore((s) => s.voxelSizeMm);
  const setVoxelSizeMm = useGlobalStore((s) => s.setVoxelSizeMm);
  const title = useGlobalStore((s) => (s as any).title);
  const setTitle = useGlobalStore((s) => (s as any).setTitle);
  const cloudProjectId = useGlobalStore((s) => (s as any).cloudProjectId);
  const setCloudProjectId = useGlobalStore((s) => (s as any).setCloudProjectId);
  const tool = useGlobalStore((s) => s.tool);
  const setTool = useGlobalStore((s) => s.setTool);
  const toolStart = useGlobalStore((s) => s.toolStart);
  const setToolStart = useGlobalStore((s) => s.setToolStart);
  const previewPixels = useGlobalStore((s) => s.previewPixels);
  const setPreviewPixels = useGlobalStore((s) => s.setPreviewPixels);
  const undoStack = useGlobalStore((s) => s.undoStack);
  const setUndoStack = useGlobalStore((s) => s.setUndoStack);
  const redoStack = useGlobalStore((s) => s.redoStack);
  const setRedoStack = useGlobalStore((s) => s.setRedoStack);
  const [networkLoading, setNetworkLoading] = useState(false);
  const [lastSavedAt, setLastSavedAt] = useState<string | null>(null);

  async function handleSignIn() {
    try {
      await signInWithPopup(auth, provider);
      toast.success('Signed in!');
    } catch (e) {
      toast.error('Sign in failed');
    }
  }

  async function updateCloudProject(id: string | null) {
    if (!user) { toast.error('Sign in to update projects'); return; }
    if (!id) { toast.error('No project selected'); return; }
    if (!plot) { toast.error('No plot to save'); return; }
    setNetworkLoading(true);
    try {
      const d = doc(db, 'users', user.uid, 'projects', id as string);
      const data = { title: title || 'Untitled', plot, voxelSizeMm, size, updatedAt: serverTimestamp() };
      await setDoc(d, data, { merge: true });
      setCloudProjectId(id);
      setLastSavedAt(new Date().toISOString());
      toast.success('Updated cloud project');
      await fetchCloudProjects();
    } catch (e) {
      console.error(e);
      toast.error('Failed updating project');
    } finally {
      setNetworkLoading(false);
    }
  }

  // Cloud modal and project management
  const [cloudModalOpen, setCloudModalOpen] = useState(false);
  const [cloudProjects, setCloudProjects] = useState<any[]>([]);
  const [selectedCloudId, setSelectedCloudId] = useState<string | null>(null);
  const [deleteConfirmOpen, setDeleteConfirmOpen] = useState(false);
  const [deleteTargetId, setDeleteTargetId] = useState<string | null>(null);

  async function fetchCloudProjects() {
    if (!user) { toast.error('Sign in to load cloud projects'); return; }
    setNetworkLoading(true);
    try {
      const ref = collection(db, 'users', user.uid, 'projects');
      const snap = await getDocs(ref);
      const projects = snap.docs.map(d => ({ id: d.id, ...(d.data() as any) }));
      setCloudProjects(projects);
      // if we have a selected cloudProjectId, update lastSavedAt from the projects list
      if (cloudProjectId) {
        const found = projects.find((p: any) => p.id === cloudProjectId);
        if (found && found.updatedAt) {
          try {
            const ts = (found.updatedAt as any);
            const parsed = ts && typeof ts.toDate === 'function' ? ts.toDate().toISOString() : (typeof ts === 'string' ? ts : new Date().toISOString());
            setLastSavedAt(parsed as string);
          } catch {
            setLastSavedAt(new Date().toISOString());
          }
        }
      }
    } catch (e) {
      console.error(e);
      toast.error('Failed fetching cloud projects');
    } finally {
      setNetworkLoading(false);
    }
  }

  async function openCloudManager() {
    await fetchCloudProjects();
    setCloudModalOpen(true);
  }



  async function loadCloudProject(p: any) {
    if (!p) return;
    if (p.plot) {
      setPlot(p.plot);
      if (p.size) setSize(p.size);
      if (typeof p.voxelSizeMm === 'number') setVoxelSizeMm(p.voxelSizeMm);
      if (p.title) setTitle(p.title);
      setCloudProjectId(p.id);
      if (p.updatedAt) {
        try {
          const ts = (p.updatedAt as any);
          const parsed = ts && typeof ts.toDate === 'function' ? ts.toDate().toISOString() : (typeof ts === 'string' ? ts : new Date().toISOString());
          setLastSavedAt(parsed as string);
        } catch {
          setLastSavedAt(new Date().toISOString());
        }
      } else setLastSavedAt(new Date().toISOString());
      toast.success('Loaded project from Firestore');
    }
  }

  function requestDeleteCloudProject(id: string) {
    // open modal to confirm
    setDeleteTargetId(id);
    setDeleteConfirmOpen(true);
  }

  async function performDeleteCloudProject() {
    const id = deleteTargetId;
    if (!id) return;
    if (!user) { toast.error('Sign in to delete cloud projects'); setDeleteConfirmOpen(false); return; }
    setNetworkLoading(true);
    try {
      await deleteDoc(doc(db, 'users', user.uid, 'projects', id));
      // refresh list
      await fetchCloudProjects();
      if (cloudProjectId === id) setCloudProjectId(null);
      toast.success('Deleted cloud project');
    } catch (e) {
      console.error(e);
      toast.error('Failed deleting project');
    } finally {
      setNetworkLoading(false);
      setDeleteConfirmOpen(false);
      setDeleteTargetId(null);
    }
  }

  function setSelectionForModal(id: string | null) {
    setSelectedCloudId(id);
  }

  function applySelectionAsCurrent(id: string | null) {
    setCloudProjectId(id);
    setCloudModalOpen(false);
    toast.info('Selected cloud project set for updates');
  }
  useEffect(() => {
    function handleEscape(e: KeyboardEvent) {
      if (e.key === 'Escape') {
        // Cancel all current actions, but only reset tool if not in a shape tool
        setToolStart(null);
        setPreviewPixels([]);
        setCurrentPixel(undefined);
        setColorMenuOpen(false);
        if (tool !== 'line' && tool !== 'circle' && tool !== 'rectangle') {
          setTool('pencil');
        }
        // Close MenuBar if open
        window.dispatchEvent(new Event('pixel-app-close-menu'));
        // Force re-render to ensure ToolBar updates
        forceUpdate(n => n + 1);
      }
    }
    window.addEventListener('keydown', handleEscape);
    return () => window.removeEventListener('keydown', handleEscape);
  }, [tool]);
  // Handle mouse movement for custom cursor (local state)
  useEffect(() => {
    const handleMouseMove = (e: MouseEvent) => {
      setMousePos({ x: e.clientX, y: e.clientY });
    };
    window.addEventListener('mousemove', handleMouseMove);
    return () => {
      window.removeEventListener('mousemove', handleMouseMove);
    };
  }, []);

  // Mobile interactions: pinch-to-zoom and double-tap to reset
  useEffect(() => {
    let lastTap = 0;
    let pinchStartDist = 0;
    let startCellSize = cellSize;
    const plotEl = () => document.querySelector('.plot') as HTMLElement | null;
    function dist(a: Touch, b: Touch) {
      const dx = a.clientX - b.clientX; const dy = a.clientY - b.clientY; return Math.hypot(dx, dy);
    }
    function onTouchStart(e: TouchEvent) {
      if (window.innerWidth >= 600) return;
      if (e.touches.length === 1) {
        const now = Date.now();
        if (now - lastTap < 300) {
          setCellSize(20);
        }
        lastTap = now;
      } else if (e.touches.length === 2) {
        pinchStartDist = dist(e.touches[0], e.touches[1]);
        startCellSize = cellSize;
      }
    }
    function onTouchMove(e: TouchEvent) {
      if (window.innerWidth >= 600) return;
      if (e.touches.length === 2) {
        e.preventDefault();
        const d = dist(e.touches[0], e.touches[1]);
        const ratio = d / (pinchStartDist || d);
        const newSize = Math.max(6, Math.min(60, Math.round(startCellSize * ratio)));
        setCellSize(newSize);
      }
    }
    const el = plotEl();
    if (el) {
      el.addEventListener('touchstart', onTouchStart as any, { passive: false });
      el.addEventListener('touchmove', onTouchMove as any, { passive: false });
    }
    return () => {
      if (el) {
        el.removeEventListener('touchstart', onTouchStart as any);
        el.removeEventListener('touchmove', onTouchMove as any);
      }
    };
  }, [cellSize]);

  // Responsive cell size: compute based on viewport width and `size` (pixel count)
  useEffect(() => {
    function calculateCellSize() {
      const margin = 32; // horizontal margins
      // Prefer measuring the plot container so desktop layout doesn't grow indefinitely
      const plotEl = document.querySelector('.plot') as HTMLElement | null;
      const containerWidth = plotEl ? Math.max(160, plotEl.clientWidth - margin) : Math.max(160, window.innerWidth - margin);
      const count = size || 16;
      const candidate = Math.floor(containerWidth / count);
      // clamp to reasonable touch sizes
      const clamped = Math.max(6, Math.min(candidate, 48));
      setCellSize(clamped);
    }
    // initial calc and on resize
    calculateCellSize();
    window.addEventListener('resize', calculateCellSize);
    // also observe container resize (in case of layout changes)
    let ro: ResizeObserver | null = null;
    const plotEl = document.querySelector('.plot') as HTMLElement | null;
    if (plotEl && typeof ResizeObserver !== 'undefined') {
      ro = new ResizeObserver(() => calculateCellSize());
      ro.observe(plotEl);
    }
    return () => {
      window.removeEventListener('resize', calculateCellSize);
      if (ro && plotEl) ro.unobserve(plotEl);
    };
  }, [size]);

  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key === 'Shift') setShiftButtonEngaged(true)
    }
    const handleKeyUp = (e: KeyboardEvent) => {
      if (e.key === 'Shift') setShiftButtonEngaged(false)
    }

    window.addEventListener('keydown', handleKeyDown)
    window.addEventListener('keyup', handleKeyUp)

    return () => {
      window.removeEventListener('keydown', handleKeyDown)
      window.removeEventListener('keyup', handleKeyUp)
    }
  }, [])


  function handleClear() {
    // Clear the current board using the current size (pixel count)
    const dsMap: string[][] = Array.from({ length: size }, () => Array.from({ length: size }, () => "transparent"));
    setPlot(dsMap);
    toast.success("Board cleared");
  }
  function floodFill(startX: number, startY: number, color?: string) {
    const fillColor = color ?? currColor
    if (!plot) return
    const newPlot = utilFloodFill(plot, startX, startY, fillColor)
    setPlot(newPlot)
    toast.success('Fill applied')
  }

  // (handleFill removed â€” not used)






  // extended palette
  // Added more colors for a richer palette
  // Basic + extended web colors + some nice extras
  let colors: string[] = [
    // Pantone-inspired swatch book: vibrant, pastel, and neutral
    // Vibrant primaries
    '#F44336', // Pantone Red
    '#E91E63', // Pantone Pink
    '#9C27B0', // Pantone Purple
    '#673AB7', // Pantone Violet
    '#3F51B5', // Pantone Blue
    '#2196F3', // Pantone Sky Blue
    '#03A9F4', // Pantone Light Blue
    '#00BCD4', // Pantone Cyan
    '#009688', // Pantone Teal
    '#4CAF50', // Pantone Green
    '#8BC34A', // Pantone Light Green
    '#CDDC39', // Pantone Lime
    '#FFEB3B', // Pantone Yellow
    '#FFC107', // Pantone Amber
    '#FF9800', // Pantone Orange
    '#FF5722', // Pantone Deep Orange
    '#795548', // Pantone Brown
    '#9E9E9E', // Pantone Gray
    '#607D8B', // Pantone Blue Gray
    '#FFFFFF', // White
    '#000000', // Black
    // Pastels
    '#FFD1DC', // Pastel Pink
    '#B5EAD7', // Pastel Mint
    '#C7CEEA', // Pastel Lavender
    '#FFDAC1', // Pastel Peach
    '#E2F0CB', // Pastel Green
    '#FFB7B2', // Pastel Coral
    '#B5B9FF', // Pastel Blue
    '#FFFACD', // Pastel Lemon
    '#F1CBFF', // Pastel Purple
    '#C1F0F6', // Pastel Aqua
    // Neutrals
    '#ECECEC', // Light Gray
    '#B0A990', // Taupe
    '#A9A9A9', // Dark Gray
    '#D7CCC8', // Warm Gray
    '#CFCFC4', // Cool Gray
    '#BDBDBD', // Silver Gray
    '#F5F5F5', // Off White
    '#D2B48C', // Tan
    '#A0522D', // Sienna
    '#8B4513', // Saddle Brown
    // Pantone brights
    '#FF6F61', // Living Coral
    '#6B5B95', // Ultra Violet
    '#88B04B', // Greenery
    '#F7CAC9', // Rose Quartz
    '#92A8D1', // Serenity
    '#955251', // Marsala
    '#B565A7', // Radiant Orchid
    '#009B77', // Emerald
    '#DD4124', // Tangerine Tango
    '#D65076', // Pink Yarrow
    '#45B8AC', // Turquoise
    '#EFC050', // Mimosa
    '#5B5EA6', // Classic Blue
    '#9B2335', // Chili Pepper
    '#DFCFBE', // Sand
    '#55B4B0', // Biscay Green
    '#E15D44', // Flame
    '#BC243C', // Jester Red
    '#C3447A', // Magenta Purple
    '#98B4D4', // Little Boy Blue
    '#C964CF', // Crocus Petal
    '#FFA756', // Mango Mojito
    '#BFD641', // Lime Punch
    '#00A591', // Arcadia
    '#F0EAD6', // Soybean
    '#D6CADD', // Lavender Gray
    '#EAE6DA', // Almond Oil
    '#B4835B', // Meerkat
    '#F3E96B', // Aspen Gold
    '#F7786B', // Peach Echo
    '#6C4F3D', // Rocky Road
    '#DEC7A6', // Sweet Corn
    '#BCB7B6', // Oyster Mushroom
    '#B2BEB5', // Quiet Gray
    '#EDE6DB', // Vanilla Custard
    '#EAE1DF', // Blanc de Blanc
    '#D8CAB8', // CrÃ¨me de PÃªche
    '#E5D3B3', // Lemon Meringue
    '#F6E3B4', // Golden Glow
    '#F9E076', // Sunlight
    '#F7C59F', // Apricot
    '#F5B895', // Coral Sands
    '#F6D155', // Primrose Yellow
    '#EFC7B7', // Rose Water
    '#F7CAC9', // Pale Dogwood
    '#BFD8B8', // Seafoam Green
    '#B5B9FF', // Periwinkle
    '#B7C9E2', // Powder Blue
    '#B2A1A1', // Mushroom
    '#B9B8B5', // Silver Lining
    '#B5B5B5', // Gray Violet
  ];
  useEffect(() => {
    if (!plot) {
      const rows = multiplier(size, 10)
      const cols = multiplier(size, 10)
      let dsMap: string[][] = Array.from({ length: rows }, () => Array.from({ length: cols }, () => "hsl(0deg 0% 100% / 16%)"));
      setPlot(dsMap)
    }
  }, [])
  // initialize a 10x10 grid of color strings (avoid shared references)
  useEffect(() => {
    //  setPlot()
  }, [currentPixel, plot])


  function pushUndo() {
    if (plot) setUndoStack([...undoStack, plot.map(row => [...row])]);
    setRedoStack([]);
  }

  function undo() {
    if (undoStack.length === 0) return;
    setRedoStack([plot!.map(row => [...row]), ...redoStack]);
    setPlot(undoStack[undoStack.length - 1]);
    setUndoStack(undoStack.slice(0, -1));
    setPreviewPixels([]);
    setToolStart(null);
  }

  function redo() {
    if (redoStack.length === 0) return;
    setUndoStack([...undoStack, plot!.map(row => [...row])]);
    setPlot(redoStack[0]);
    setRedoStack(redoStack.slice(1));
    setPreviewPixels([]);
    setToolStart(null);
  }

  function setPixelAt(params: { x: number; y: number }, color: string) {
    pushUndo();
    setCurrentPixel(params);
    if (!plot) return;
    const newPlot = plot.map(row => row.slice());
    if (newPlot[params.x] && typeof newPlot[params.x][params.y] !== 'undefined') {
      newPlot[params.x][params.y] = color;
    }
    setPlot(newPlot);
  }

  function handleSetPixel(params: { x: number; y: number }) {
    // Haptic feedback: vibrate for 10ms if supported
    if (navigator.vibrate) {
      navigator.vibrate(10);
    }
    if (tool === 'pencil') {
      setPixelAt(params, currColor || 'transparent')
      setPreviewPixels([])
    } else if (tool === 'eraser') {
      setPixelAt(params, 'transparent')
      setPreviewPixels([])
    } else if (tool === 'fill') {
      pushUndo();
      floodFill(params.x, params.y, currColor)
      setPreviewPixels([])
    } else if (tool === 'picker') {
      const c = plot?.[params.x]?.[params.y]
      if (c) setCurrColor(c)
      setPreviewPixels([])
    } else if (tool === 'line' || tool === 'circle' || tool === 'rectangle') {
      if (!toolStart) {
        setToolStart(params)
      } else {
        pushUndo();
        if (tool === 'line') drawLine(toolStart, params, currColor || 'transparent')
        if (tool === 'circle') drawCircle(toolStart, params, currColor || 'transparent')
        if (tool === 'rectangle') drawRectangle(toolStart, params, currColor || 'transparent')
        setToolStart(null)
        setPreviewPixels([])
      }
    }
  }
  // Preview overlay for line/circle/rectangle
  function handlePreview(to: { x: number; y: number }) {
    if (!toolStart) return setPreviewPixels([])
    if (tool === 'line') {
      setPreviewPixels(getLinePixels(toolStart, to))
    } else if (tool === 'circle') {
      setPreviewPixels(getCirclePerimeterPixels(toolStart, to))
    } else if (tool === 'rectangle') {
      setPreviewPixels(getRectanglePerimeterPixels(toolStart, to))
    } else {
      setPreviewPixels([])
    }
  }

  function getRectanglePerimeterPixels(a: { x: number; y: number }, b: { x: number; y: number }) {
    return utilGetRectanglePerimeterPixels(a as any, b as any);
  }

  function drawRectangle(a: { x: number; y: number }, b: { x: number; y: number }, color: string) {
    if (!plot) return;
    const newPlot = utilDrawRectanglePlot(plot, a as any, b as any, color);
    setPlot(newPlot);
  }

  function getLinePixels(a: { x: number; y: number }, b: { x: number; y: number }) {
    return utilGetLinePixels(a as any, b as any);
  }

  function getCirclePerimeterPixels(center: { x: number; y: number }, edge: { x: number; y: number }) {
    return utilGetCirclePerimeterPixels(center as any, edge as any);
  }

  // Bresenham line algorithm (delegates to util)
  function drawLine(a: { x: number; y: number }, b: { x: number; y: number }, color: string) {
    if (!plot) return;
    const newPlot = utilDrawLinePlot(plot, a as any, b as any, color);
    setPlot(newPlot);
  }

  // Draw circle (delegates to util)
  function drawCircle(center: { x: number; y: number }, edge: { x: number; y: number }, color: string) {
    if (!plot) return;
    const newPlot = utilDrawCirclePlot(plot, center as any, edge as any, color);
    setPlot(newPlot);
  }

  function handleMouseEnterPixel(params: { x: number; y: number }) {
    if (shiftButtonEngaged) {
      handleSetPixel(params)
    }
  }

  function handleMouseLeavePixel() {

  }


  function generateBlenderScript() {
    return utilGenerateBlenderScript(plot as any, voxelSizeMm);
  }





  // Save project JSON to file and localStorage
  function saveProject(mode: 'save' | 'saveAs' = 'save') {
    if (!plot) {
      toast.error('No plot to save')
      return
    }
    try {
      const data = { plot, voxelSizeMm, title: title || 'Untitled', size }
      const txt = JSON.stringify(data)
      const blob = new Blob([txt], { type: 'application/json;charset=utf-8' })
      const url = URL.createObjectURL(blob)
      const a = document.createElement('a')
      let filename = 'pixel-project.json';
      if (mode === 'saveAs') {
        const userName = window.prompt('Enter file name:', 'pixel-project.json');
        if (userName && userName.trim()) {
          filename = userName.trim().endsWith('.json') ? userName.trim() : userName.trim() + '.json';
        }
      }
      a.href = url
      a.download = filename
      document.body.appendChild(a)
      a.click()
      a.remove()
      URL.revokeObjectURL(url)
      // also save to localStorage
      try { localStorage.setItem('pixel-app-save', txt); } catch (e) { /* ignore */ }
      toast.success('Project saved')
    } catch (e) {
      toast.error('Save failed')
    }
  }

  // Load project from a File object

  // Export PNG image of the plot (scale pxPerCell)
  function exportPNG() {
    if (!plot) {
      toast.error('No plot to export')
      return
    }
    const rows = plot.length
    const cols = plot[0]?.length ?? 0
    const pxPerCell = 20
    const cvs = document.createElement('canvas')
    cvs.width = cols * pxPerCell
    cvs.height = rows * pxPerCell
    const ctx = cvs.getContext('2d')
    if (!ctx) {
      toast.error('Export failed')
      return
    }
    ctx.clearRect(0, 0, cvs.width, cvs.height)
    for (let i = 0; i < rows; i++) {
      for (let j = 0; j < cols; j++) {
        const c = plot[i][j]
        if (!c || c === 'transparent') continue
        ctx.fillStyle = c
        ctx.fillRect(j * pxPerCell, i * pxPerCell, pxPerCell, pxPerCell)
      }
    }
    cvs.toBlob((blob) => {
      if (!blob) { toast.error('Export failed'); return }
      const url = URL.createObjectURL(blob)
      const a = document.createElement('a')
      a.href = url
      a.download = 'pixel-export.png'
      document.body.appendChild(a)
      a.click()
      a.remove()
      URL.revokeObjectURL(url)
      toast.success('PNG exported')
    })
  }

  // Load autosave from localStorage on mount
  useEffect(() => {
    try {
      const s = localStorage.getItem('pixel-app-save')
      if (s) {
        const parsed = JSON.parse(s)
        if (parsed.plot) setPlot(parsed.plot)
        if (typeof parsed.voxelSizeMm === 'number') setVoxelSizeMm(parsed.voxelSizeMm)
        if (typeof parsed.size === 'number') setSize(parsed.size)
        if (typeof parsed.title === 'string') setTitle(parsed.title)
      }
    } catch (e) { }
  }, [])

  const [framesMenuOpen, setFramesMenuOpen] = useState(false)



  return (
    <div className="App">
      <ProgressBar loading={networkLoading} />

      <ToastContainer
        toastClassName="toastify-theme-pixel"
        className="toastify-theme-pixel"
        position="bottom-right"
        autoClose={1000}
        hideProgressBar={false}
        newestOnTop={false}
        closeOnClick
        rtl={false}
        pauseOnFocusLoss
        draggable
        pauseOnHover
        theme="dark"
      />
      <header>
        <MenuBar user={user} onSignIn={handleSignIn} onSignOut={handleSignOut} isSaved={!!cloudProjectId} lastSavedAt={lastSavedAt} networkLoading={networkLoading} />
      </header>
      {/* Mobile layout handled by MobileEditorLayout component */}
      {/* <div className='mini-plot'>
        {plot?.map((val: string[], i: number) => {
          return <div key={i}>{val.map((v: string, j: number) => <div onClick={() => handleSetPixel({ x: i, y: j })} className="pixel" key={j} style={{ backgroundColor: v, width: 1, height: 1 }} />)}</div>
        })}
      </div> */}
      <main className="main-content">
        {/* Frame controls */}
        <div style={{ display: 'flex', alignItems: 'center', gap: 16, marginBottom: 16, justifyContent: 'center' }}>
          <button
            style={{
              fontWeight: 600,
              background: '#23272e',
              color: '#ffb300',
              border: '1px solid #444',
              borderRadius: 6,
              padding: '8px 18px',
              cursor: 'pointer',
              fontSize: 16
            }}
            onClick={() => setFramesMenuOpen(true)}
          >
            Frames
          </button>
          <span style={{ marginLeft: 24, fontWeight: 500 }}>Pixel Count:</span>
          <input
            type="number"
            min={2}
            max={64}
            value={size}
            onChange={e => setSize(Number(e.target.value))}
            className="pixel-count-input"
          />
          <span style={{ marginLeft: 12, fontWeight: 500 }}>Title:</span>
          <input
            type="text"
            value={title}
            onChange={e => setTitle(e.target.value)}
            placeholder="Untitled"
            style={{ padding: '6px 10px', borderRadius: 6, border: '1px solid #444', background: '#23272e', color: '#f5f5f7' }}
          />
          <button disabled={networkLoading} onClick={() => saveProjectToFirestore(false)} style={{ background: '#23272e', color: '#ffb300', border: '1px solid #444', borderRadius: 6, padding: '8px 12px', cursor: networkLoading ? 'wait' : 'pointer', opacity: networkLoading ? 0.7 : 1 }}> {networkLoading ? 'Saving...' : 'Save to Cloud'}</button>
          <button disabled={networkLoading} onClick={() => saveProjectToFirestore(true)} style={{ background: '#23272e', color: '#f5f5f7', border: '1px solid #444', borderRadius: 6, padding: '8px 12px', cursor: networkLoading ? 'wait' : 'pointer', opacity: networkLoading ? 0.7 : 1 }}> {networkLoading ? 'Working...' : 'Save As'}</button>
          <button onClick={openCloudManager} style={{ background: '#23272e', color: '#f5f5f7', border: '1px solid #444', borderRadius: 6, padding: '8px 12px', cursor: 'pointer' }}>Cloud Manager</button>
        </div>
        <FramesModal
          open={framesMenuOpen}
          onClose={() => setFramesMenuOpen(false)}
          frames={frames}
          currentFrame={currentFrame}
          setCurrentFrame={setCurrentFrame}
          addFrame={addFrame}
          removeFrame={removeFrame}
        />
        <CloudProjectsModal
          open={cloudModalOpen}
          onClose={() => setCloudModalOpen(false)}
          projects={cloudProjects}
          onLoad={async (p) => { await loadCloudProject(p); setCloudModalOpen(false); }}
          onDelete={(id) => { requestDeleteCloudProject(id); }}
          onUpdate={(id) => { updateCloudProject(id); }}
          onSelect={(id) => setSelectionForModal(id)}
          selectedId={selectedCloudId}
          onUpdateSelection={(id) => applySelectionAsCurrent(id)}
          loading={networkLoading}
        />
        <ConfirmationModal
          open={deleteConfirmOpen}
          title="Delete cloud project"
          message="Delete this project from the cloud? This cannot be undone."
          onConfirm={() => performDeleteCloudProject()}
          onCancel={() => { setDeleteConfirmOpen(false); setDeleteTargetId(null); }}
          confirmLabel="Delete"
        />
        <div
          className='plot'
          onMouseEnter={() => setShowToolCursor(true)}
          onMouseLeave={() => setShowToolCursor(false)}
        >
          {plot?.map((val: string[], i: number) => {
            return <div key={i}>{val.map((v: string, j: number) => {
              const isPreview = previewPixels.some(p => p.x === i && p.y === j)
              return (
                <div
                  onMouseEnter={() => { handleMouseEnterPixel({ x: i, y: j }); if (toolStart && (tool === 'line' || tool === 'circle' || tool === 'rectangle')) handlePreview({ x: i, y: j }) }}
                  onMouseLeave={handleMouseLeavePixel}
                  onClick={() => handleSetPixel({ x: i, y: j })}
                  className={`pixel${isPreview ? ' preview' : ''}`}
                  key={j}
                  style={{ backgroundColor: isPreview ? currColor : v, opacity: isPreview ? 0.5 : 1, width: cellSize, height: cellSize }} />
              )
            })}</div>
          })}
        </div>
      </main>
      {showToolCursor && (
        <div
          id="cursor"
          className="custom-cursor filled-circle"
          style={{
            position: 'fixed',
            // Offset: 10px right, 10px down from pointer
            left: `${mousePos.x + 10}px`,
            top: `${mousePos.y + 10}px`,
            pointerEvents: 'none',
            transform: 'translate(-50%, -50%)',
            zIndex: 9999,
          }}
        >
          <div className="cursor-color-indicator small" style={{ background: currColor }} />
        </div>
      )}
      {isMobile && (
        <button aria-label="Open color picker" className="fab" onClick={() => setColorMenuOpen(true)} title="Color Picker">
          ðŸŽ¨
        </button>
      )}
      <div id="picker" className='color'></div>
      <ToolBar
        setColorMenuOpen={setColorMenuOpen}
        handleClear={handleClear}
        tool={tool}
        setTool={setTool}
        undo={undo}
        redo={redo}
      />
      <ColorModal
        open={colorMenuOpen}
        onClose={() => setColorMenuOpen(false)}
        colors={colors}
        currColor={currColor}
        setCurrColor={setCurrColor}
      />
    </div>


  )
}



export default App